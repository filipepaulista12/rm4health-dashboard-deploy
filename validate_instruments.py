#!/usr/bin/env python3
"""Script para validar an√°lise detalhada dos 11 instrumentos com explica√ß√µes para leigos"""

from local_redcap_client import LocalREDCapClient
from data_processor import DataProcessor

def validate_instruments_analysis():
    print("=== VALIDA√á√ÉO AN√ÅLISE DETALHADA DOS INSTRUMENTOS ===")
    print("Analisando os 11 question√°rios/escalas cl√≠nicas usados no RM4Health\n")
    
    # Carregar dados
    client = LocalREDCapClient()
    data = client.get_records(raw_or_label='raw')
    
    if not data:
        print("‚ùå Dados n√£o dispon√≠veis")
        return
    
    dp = DataProcessor(data)
    print(f"üìä Analisando {len(data)} registos de dados...\n")
    
    # 1. IDENTIFICAR INSTRUMENTOS PELOS CAMPOS _complete
    print("üîç 1. IDENTIFICA√á√ÉO DOS INSTRUMENTOS")
    print("   O que s√£o: Question√°rios e escalas validadas para avaliar diferentes aspetos da sa√∫de")
    
    complete_fields = []
    for record in data[:10]:  # Examinar primeiros 10 registos
        for field_name in record.keys():
            if field_name.endswith('_complete'):
                complete_fields.append(field_name)
    
    # Remover duplicados e contar
    unique_instruments = list(set(complete_fields))
    
    print(f"\n   Instrumentos encontrados ({len(unique_instruments)}):")
    instrument_names = {}
    for i, field in enumerate(sorted(unique_instruments), 1):
        instrument_name = field.replace('_complete', '').replace('_', ' ').title()
        instrument_names[field] = instrument_name
        print(f"   {i}. {instrument_name}")
        
        # Explica√ß√£o para leigos de cada instrumento
        if 'barthel' in field.lower():
            print(f"      ‚Üí Avalia independ√™ncia nas atividades b√°sicas (comer, vestir, caminhar)")
        elif 'eq5d' in field.lower():
            print(f"      ‚Üí Mede qualidade de vida em 5 dimens√µes (mobilidade, cuidados pessoais, etc.)")
        elif 'pittsburgh' in field.lower() or 'sono' in field.lower():
            print(f"      ‚Üí Avalia qualidade do sono e problemas de ins√≥nia")
        elif 'caracterizacao' in field.lower():
            print(f"      ‚Üí Recolhe dados socioecon√≥micos (educa√ß√£o, rendimento, habita√ß√£o)")
        elif 'preferencias' in field.lower():
            print(f"      ‚Üí Avalia h√°bitos, rotinas e prefer√™ncias de atividades")
        elif 'medicacao' in field.lower():
            print(f"      ‚Üí Monitoriza ades√£o aos medicamentos e bem-estar")
        elif 'utilizacao' in field.lower() and 'servicos' in field.lower():
            print(f"      ‚Üí Regista uso de servi√ßos de sa√∫de (consultas, emerg√™ncias, hospitaliza√ß√µes)")
        elif 'tecnologias' in field.lower():
            print(f"      ‚Üí Avalia familiaridade e uso de tecnologias de sa√∫de")
        elif 'plano' in field.lower() and 'terapeutico' in field.lower():
            print(f"      ‚Üí Regista plano de medicamentos prescritos")
        elif 'estado' in field.lower() and 'saude' in field.lower():
            print(f"      ‚Üí Lista diagn√≥sticos e condi√ß√µes de sa√∫de pr√©vias")
        elif 'participante' in field.lower():
            print(f"      ‚Üí Dados b√°sicos do participante (identifica√ß√£o, grupo)")
    
    print()
    
    # 2. CALCULAR TAXAS DE COMPLETUDE POR INSTRUMENTO
    print("üìà 2. TAXAS DE COMPLETUDE POR INSTRUMENTO")
    print("   O que significa: Percentagem de participantes que completaram cada question√°rio")
    
    total_records = len(data)
    instrument_completeness = {}
    
    for field in unique_instruments:
        completed_count = 0
        incomplete_count = 0
        not_started_count = 0
        
        for record in data:
            value = record.get(field, '')
            if str(value).strip() in ['2', 'complete', 'completed']:
                completed_count += 1
            elif str(value).strip() in ['1', 'incomplete', 'partial']:
                incomplete_count += 1
            else:
                not_started_count += 1
        
        completion_rate = (completed_count / total_records * 100) if total_records > 0 else 0
        instrument_completeness[field] = {
            'completed': completed_count,
            'incomplete': incomplete_count,
            'not_started': not_started_count,
            'completion_rate': completion_rate
        }
        
        print(f"\n   üìã {instrument_names[field]}:")
        print(f"      ‚Ä¢ Completos: {completed_count} ({completion_rate:.1f}%)")
        print(f"      ‚Ä¢ Incompletos: {incomplete_count}")
        print(f"      ‚Ä¢ N√£o iniciados: {not_started_count}")
        
        # Interpreta√ß√£o para leigos
        if completion_rate >= 90:
            interpretation = "Excelente ades√£o! Quase todos os participantes completaram."
        elif completion_rate >= 75:
            interpretation = "Boa ades√£o! A maioria dos participantes completou."
        elif completion_rate >= 50:
            interpretation = "Ades√£o moderada. Metade dos participantes completou."
        else:
            interpretation = "Baixa ades√£o. Poucos participantes completaram."
        
        print(f"      üí° Para leigos: {interpretation}")
    
    print()
    
    # 3. DISTRIBUI√á√ÉO POR PARTICIPANTE
    print("üë• 3. DISTRIBUI√á√ÉO POR PARTICIPANTE")
    print("   O que significa: Quantos question√°rios cada participante completou")
    
    # Agregar por participante
    participant_completions = {}
    for record in data:
        participant_id = record.get('participant_code', record.get('record_id', 'unknown'))
        
        if participant_id not in participant_completions:
            participant_completions[participant_id] = {
                'completed': 0,
                'total_instruments': len(unique_instruments)
            }
        
        # Contar instrumentos completos para este participante
        for field in unique_instruments:
            value = record.get(field, '')
            if str(value).strip() in ['2', 'complete', 'completed']:
                participant_completions[participant_id]['completed'] += 1
                break  # Evitar contar o mesmo instrumento m√∫ltiplas vezes
    
    # Calcular estat√≠sticas de distribui√ß√£o
    completion_counts = [p['completed'] for p in participant_completions.values()]
    avg_completion = sum(completion_counts) / len(completion_counts) if completion_counts else 0
    min_completion = min(completion_counts) if completion_counts else 0
    max_completion = max(completion_counts) if completion_counts else 0
    
    # Distribui√ß√£o por faixas
    distribution = {
        'all_completed': len([c for c in completion_counts if c == len(unique_instruments)]),
        'mostly_completed': len([c for c in completion_counts if c >= len(unique_instruments) * 0.8 and c < len(unique_instruments)]),
        'partially_completed': len([c for c in completion_counts if c >= len(unique_instruments) * 0.5 and c < len(unique_instruments) * 0.8]),
        'few_completed': len([c for c in completion_counts if c < len(unique_instruments) * 0.5])
    }
    
    print(f"\n   üìä Estat√≠sticas de completude por participante:")
    print(f"      ‚Ä¢ M√©dia de instrumentos completados: {avg_completion:.1f}/{len(unique_instruments)}")
    print(f"      ‚Ä¢ M√≠nimo: {min_completion} instrumentos")
    print(f"      ‚Ä¢ M√°ximo: {max_completion} instrumentos")
    
    print(f"\n   üìà Distribui√ß√£o dos participantes:")
    total_participants = len(participant_completions)
    print(f"      ‚Ä¢ Completaram tudo ({len(unique_instruments)}/{len(unique_instruments)}): {distribution['all_completed']} participantes ({distribution['all_completed']/total_participants*100:.1f}%)")
    print(f"      ‚Ä¢ Completaram quase tudo (‚â•80%): {distribution['mostly_completed']} participantes ({distribution['mostly_completed']/total_participants*100:.1f}%)")
    print(f"      ‚Ä¢ Completaram metade (50-80%): {distribution['partially_completed']} participantes ({distribution['partially_completed']/total_participants*100:.1f}%)")
    print(f"      ‚Ä¢ Completaram pouco (<50%): {distribution['few_completed']} participantes ({distribution['few_completed']/total_participants*100:.1f}%)")
    
    print(f"\n   üí° Para leigos:")
    if distribution['all_completed'] / total_participants >= 0.8:
        print("      Excelente! A maioria dos participantes completou todos os question√°rios.")
    elif distribution['all_completed'] / total_participants >= 0.6:
        print("      Muito bom! A maioria dos participantes teve alta completude.")
    elif distribution['all_completed'] / total_participants >= 0.4:
        print("      Razo√°vel! Cerca de metade dos participantes completou bem os question√°rios.")
    else:
        print("      Precisa melhorar! Muitos participantes n√£o completaram os question√°rios.")
    
    print()
    
    # 4. VALIDA√á√ÉO DE DADOS POR INSTRUMENTO
    print("üîç 4. VALIDA√á√ÉO DE DADOS POR INSTRUMENTO")
    print("   O que significa: Verificar se os dados coletados fazem sentido e s√£o v√°lidos")
    
    # Para cada instrumento, verificar campos relacionados
    validation_results = {}
    
    for field in unique_instruments:
        instrument_base = field.replace('_complete', '')
        
        # Procurar campos relacionados a este instrumento
        related_fields = []
        for record in data[:1]:  # Usar primeiro registo para examinar estrutura
            for field_name in record.keys():
                if instrument_base in field_name and field_name != field:
                    related_fields.append(field_name)
        
        # Calcular estat√≠sticas de preenchimento dos campos relacionados
        if related_fields:
            total_possible = len(data) * len(related_fields)
            filled_fields = 0
            
            for record in data:
                for related_field in related_fields:
                    value = record.get(related_field, '')
                    if value is not None and str(value).strip() != '':
                        filled_fields += 1
            
            data_quality = (filled_fields / total_possible * 100) if total_possible > 0 else 0
        else:
            data_quality = 0
        
        validation_results[field] = {
            'related_fields_count': len(related_fields),
            'data_quality': data_quality
        }
        
        print(f"\n   üìã {instrument_names[field]}:")
        print(f"      ‚Ä¢ Campos de dados: {len(related_fields)}")
        print(f"      ‚Ä¢ Qualidade dos dados: {data_quality:.1f}%")
        
        # Interpreta√ß√£o para leigos
        if data_quality >= 90:
            quality_interpretation = "Dados excelentes! Quase todos os campos est√£o preenchidos."
        elif data_quality >= 75:
            quality_interpretation = "Dados bons! A maioria dos campos est√° preenchida."
        elif data_quality >= 50:
            quality_interpretation = "Dados razo√°veis! Metade dos campos est√° preenchida."
        else:
            quality_interpretation = "Dados insuficientes! Muitos campos est√£o vazios."
        
        print(f"      üí° Para leigos: {quality_interpretation}")
    
    print()
    
    # 5. RESUMO EXECUTIVO
    print("üèÜ RESUMO EXECUTIVO - AN√ÅLISE DE INSTRUMENTOS")
    
    overall_completion = sum([stats['completion_rate'] for stats in instrument_completeness.values()]) / len(instrument_completeness)
    overall_data_quality = sum([stats['data_quality'] for stats in validation_results.values()]) / len(validation_results)
    
    print(f"\n   üìä M√©tricas Gerais:")
    print(f"      ‚Ä¢ Total de instrumentos: {len(unique_instruments)}")
    print(f"      ‚Ä¢ Taxa m√©dia de completude: {overall_completion:.1f}%")
    print(f"      ‚Ä¢ Qualidade m√©dia dos dados: {overall_data_quality:.1f}%")
    print(f"      ‚Ä¢ Participantes com completude alta (‚â•80%): {(distribution['all_completed'] + distribution['mostly_completed'])/total_participants*100:.1f}%")
    
    print(f"\n   üéØ Interpreta√ß√£o para leigos:")
    if overall_completion >= 80 and overall_data_quality >= 80:
        print("      ‚úÖ EXCELENTE! O projeto tem dados de alta qualidade e boa participa√ß√£o.")
    elif overall_completion >= 70 and overall_data_quality >= 70:
        print("      ‚úÖ MUITO BOM! O projeto tem dados s√≥lidos para an√°lises cient√≠ficas.")
    elif overall_completion >= 60 and overall_data_quality >= 60:
        print("      ‚ö†Ô∏è BOM! O projeto tem dados utiliz√°veis mas pode melhorar.")
    else:
        print("      ‚ö†Ô∏è PRECISA MELHORAR! Os dados t√™m qualidade insuficiente para algumas an√°lises.")
    
    print(f"\n   üìã Instrumentos com melhor performance:")
    # Top 3 instrumentos por taxa de completude
    sorted_instruments = sorted(instrument_completeness.items(), key=lambda x: x[1]['completion_rate'], reverse=True)
    for i, (field, stats) in enumerate(sorted_instruments[:3], 1):
        print(f"      {i}. {instrument_names[field]}: {stats['completion_rate']:.1f}%")
    
    print(f"\n   ‚ö†Ô∏è Instrumentos que precisam aten√ß√£o:")
    # Bottom 3 instrumentos por taxa de completude
    for i, (field, stats) in enumerate(sorted_instruments[-3:], 1):
        print(f"      {i}. {instrument_names[field]}: {stats['completion_rate']:.1f}%")
    
    # Recomenda√ß√µes espec√≠ficas
    print(f"\n   üí° RECOMENDA√á√ïES PARA MELHORAR:")
    low_completion = [field for field, stats in instrument_completeness.items() if stats['completion_rate'] < 70]
    if low_completion:
        print("      ‚Ä¢ Focar esfor√ßos nos instrumentos com baixa completude")
        print("      ‚Ä¢ Simplificar question√°rios muito longos")
        print("      ‚Ä¢ Melhorar instru√ß√µes para participantes")
    
    if overall_data_quality < 80:
        print("      ‚Ä¢ Implementar valida√ß√£o em tempo real")
        print("      ‚Ä¢ Treinar equipa para melhor qualidade de dados")
        print("      ‚Ä¢ Adicionar campos obrigat√≥rios nos instrumentos cr√≠ticos")

if __name__ == "__main__":
    validate_instruments_analysis()